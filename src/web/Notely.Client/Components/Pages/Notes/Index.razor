@page "/notes"
@using Shared.DTOs
@using Notely.Client.Services.Notes
@inject INotesService NotesService
@inject NavigationManager Navigation
@inject IJSRuntime JS

<PageTitle>Notes</PageTitle>

<h1 class="notes-title">My Notes</h1>

<div class="notes-toolbar">
    <div class="notes-filters">
        <input
            class="form-control notes-search"
            placeholder="Search by title, content, or category"
            value="@searchTerm"
            @oninput="OnSearchChanged" />
        <div class="form-check">
            <InputCheckbox id="pinnedOnly" class="form-check-input" Value="pinnedOnly" ValueChanged="OnPinnedOnlyChanged" />
            <label for="pinnedOnly" class="form-check-label">Pinned only</label>
        </div>
        <select class="form-select notes-sort" value="@sortBy" @onchange="OnSortChanged">
            <option value="@SortMode.Newest">Newest</option>
            <option value="@SortMode.Oldest">Oldest</option>
            <option value="@SortMode.Title">Title</option>
        </select>
        <select class="form-select notes-page-size" value="@pageSize" @onchange="OnPageSizeChanged">
            <option value="6">6 / page</option>
            <option value="9">9 / page</option>
            <option value="12">12 / page</option>
        </select>
    </div>
    <button class="btn btn-primary" @onclick="CreateNote">
        <i class="fas fa-plus"></i> Create New Note
    </button>
</div>

@if (!string.IsNullOrWhiteSpace(errorMessage))
{
    <div class="alert alert-danger">@errorMessage</div>
}

@if (isLoading)
{
    <p><em>Loading...</em></p>
}
else if (!FilteredNotes.Any())
{
    <div class="alert alert-info">
        <i class="fas fa-info-circle"></i> No notes match your current filters.
    </div>
}
else
{
    <p class="notes-meta">Showing @PagedNotes.Count() of @FilteredCount filtered notes (@allNotes.Count total)</p>
    <div class="row">
        @foreach (var note in PagedNotes)
        {
            <div class="col-md-4 mb-3">
                <div class="card note-card @GetPinnedClass(note.IsPinned)" @key="note.Id">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <h5 class="card-title">@note.Title</h5>
                            <div class="d-flex gap-2">
                                @if (!string.IsNullOrEmpty(note.CategoryName))
                                {
                                    <span class="badge bg-info text-dark">
                                        <i class="fas fa-folder"></i> @note.CategoryName
                                    </span>
                                }
                                @if (note.IsPinned)
                                {
                                    <span class="badge bg-warning text-dark">
                                        <i class="fas fa-thumbtack"></i> Pinned
                                    </span>
                                }
                            </div>
                        </div>
                        <p class="card-text">
                            @if (note.Content?.Length > 100)
                            {
                                @(note.Content.Substring(0, 100) + "...")
                            }
                            else
                            {
                                @note.Content
                            }
                        </p>
                        <small class="text-muted">
                            Created: @note.CreatedAt.ToString("MMM dd, yyyy")
                        </small>
                        <div class="mt-2">
                            <button class="btn btn-sm btn-outline-primary me-2" @onclick="() => EditNote(note.Id)">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                            <button class="btn btn-sm btn-outline-danger me-2" @onclick="() => DeleteNote(note.Id)">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                            <button class="btn btn-sm @(note.IsPinned ? "btn-warning" : "btn-outline-warning")" @onclick="() => TogglePin(note.Id, note.IsPinned)">
                                <i class="fas fa-thumbtack"></i> @(note.IsPinned ? "Unpin" : "Pin")
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        }
    </div>
    <div class="notes-pagination">
        <button class="btn btn-outline-secondary" @onclick="GoToPreviousPage" disabled="@(CurrentPage <= 1)">
            Previous
        </button>
        <span class="notes-page-indicator">Page @CurrentPage of @TotalPages</span>
        <button class="btn btn-outline-secondary" @onclick="GoToNextPage" disabled="@(CurrentPage >= TotalPages)">
            Next
        </button>
    </div>
}

@code {
    private readonly List<NoteDto> allNotes = new();
    private bool isLoading = true;
    private string? errorMessage;
    private string searchTerm = string.Empty;
    private bool pinnedOnly;
    private SortMode sortBy = SortMode.Newest;
    private int currentPage = 1;
    private int pageSize = 9;

    private IEnumerable<NoteDto> FilteredNotes =>
        ApplySorting(
            allNotes.Where(note =>
                (!pinnedOnly || note.IsPinned) &&
                MatchesSearch(note, searchTerm)));

    private int FilteredCount => FilteredNotes.Count();

    private int TotalPages => Math.Max(1, (int)Math.Ceiling((double)FilteredCount / pageSize));

    private int CurrentPage => Math.Min(currentPage, TotalPages);

    private IEnumerable<NoteDto> PagedNotes =>
        FilteredNotes
            .Skip((CurrentPage - 1) * pageSize)
            .Take(pageSize);

    protected override async Task OnInitializedAsync()
    {
        await LoadNotes();
    }

    private async Task LoadNotes()
    {
        isLoading = true;
        errorMessage = null;
        try
        {
            var notes = await NotesService.GetNotesAsync();
            allNotes.Clear();
            allNotes.AddRange(notes);
        }
        catch (Exception ex)
        {
            errorMessage = "Unable to load notes. Please try again.";
            Console.WriteLine($"Error loading notes: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }

    private void CreateNote()
    {
        Navigation.NavigateTo("/notes/create");
    }

    private void EditNote(Guid id)
    {
        Navigation.NavigateTo($"/notes/edit/{id}");
    }

    private async Task DeleteNote(Guid id)
    {
        var shouldDelete = await JS.InvokeAsync<bool>("confirm", "Are you sure you want to delete this note?");
        if (!shouldDelete)
        {
            return;
        }

        try
        {
            await NotesService.DeleteNoteAsync(id);
            await LoadNotes();
        }
        catch (Exception ex)
        {
            errorMessage = "Unable to delete note. Please try again.";
            Console.WriteLine($"Error deleting note: {ex.Message}");
        }
    }

    private async Task TogglePin(Guid id, bool currentPinStatus)
    {
        try
        {
            var note = await NotesService.GetNoteAsync(id);
            if (note != null)
            {
                var updateDto = new UpdateNoteDto
                {
                    Title = note.Title,
                    Content = note.Content,
                    IsPinned = !currentPinStatus,
                    CategoryId = note.CategoryId,
                    Tags = note.Tags
                };
                
                await NotesService.UpdateNoteAsync(id, updateDto);
                await LoadNotes();
            }
        }
        catch (Exception ex)
        {
            errorMessage = "Unable to update note state. Please try again.";
            Console.WriteLine($"Error toggling pin: {ex.Message}");
        }
    }

    private static bool MatchesSearch(NoteDto note, string term)
    {
        if (string.IsNullOrWhiteSpace(term))
        {
            return true;
        }

        var query = term.Trim();
        return (note.Title?.Contains(query, StringComparison.OrdinalIgnoreCase) ?? false)
            || (note.Content?.Contains(query, StringComparison.OrdinalIgnoreCase) ?? false)
            || (note.CategoryName?.Contains(query, StringComparison.OrdinalIgnoreCase) ?? false);
    }

    private IEnumerable<NoteDto> ApplySorting(IEnumerable<NoteDto> notes) =>
        sortBy switch
        {
            SortMode.Oldest => notes.OrderByDescending(n => n.IsPinned).ThenBy(n => n.CreatedAt),
            SortMode.Title => notes.OrderByDescending(n => n.IsPinned).ThenBy(n => n.Title),
            _ => notes.OrderByDescending(n => n.IsPinned).ThenByDescending(n => n.CreatedAt)
        };

    private static string GetPinnedClass(bool isPinned) => isPinned ? "note-card-pinned" : string.Empty;

    private void OnSearchChanged(ChangeEventArgs args)
    {
        searchTerm = args.Value?.ToString() ?? string.Empty;
        ResetToFirstPage();
    }

    private Task OnPinnedOnlyChanged(bool value)
    {
        pinnedOnly = value;
        ResetToFirstPage();
        return Task.CompletedTask;
    }

    private void OnSortChanged(ChangeEventArgs args)
    {
        if (Enum.TryParse<SortMode>(args.Value?.ToString(), out var parsed))
        {
            sortBy = parsed;
            ResetToFirstPage();
        }
    }

    private void OnPageSizeChanged(ChangeEventArgs args)
    {
        if (int.TryParse(args.Value?.ToString(), out var parsed) && parsed > 0)
        {
            pageSize = parsed;
            ResetToFirstPage();
        }
    }

    private void GoToPreviousPage()
    {
        if (CurrentPage > 1)
        {
            currentPage = CurrentPage - 1;
        }
    }

    private void GoToNextPage()
    {
        if (CurrentPage < TotalPages)
        {
            currentPage = CurrentPage + 1;
        }
    }

    private void ResetToFirstPage()
    {
        currentPage = 1;
    }

    private enum SortMode
    {
        Newest,
        Oldest,
        Title
    }
}
